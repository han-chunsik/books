---
title: 구글 엔지니어는 이렇게 일한다
author: 한춘식
date: 2024-03-31
category: books
layout: post
---

> ##### 책 정보
> [구글 엔지니어는 이렇게 일한다 - 한빛미디어](https://www.yes24.com/Product/Goods/109182479?pid=123487&cosemkid=go16527542090906292&gad_source=1&gclid=Cj0KCQjwk6SwBhDPARIsAJ59GwcsarMNP-zpK97jiVfywZ2WMeJAOpajehxYm3SrTd_aEUR-G--hzdEaAvRqEALw_wcB)

---

Part 1 전제 - 1. 소프트웨어 엔지니어링이란?(p.41 ~ p.67)
-------------
_"Software engineering is programming integrated over time"_  
_"소프트웨어 엔지니어링은 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것이다"_  

**소프트웨어 엔지니어링에서 중요한 세가지**  
* time(시간) - 시간의 흐름과 언젠간 변경될 가능성
* scale(규모, 확장) - 소프트웨어와 소프트웨어를 만드는 조직 모두에서의 확장과 효율
* trade-offs at play(실전에서의 트레이드오프) - 수명과 성장 속도를 예측하기 어려운 상ㅎ황에서 결과에 더 큰 영향을 주는 복잡한 결정

**프로그래밍 != 소프트웨어 엔지니어링**  
* 프로그래밍은 소프트웨어를 제작하는 수단
* 프로그래밍 작업 == 개발
* 소프트웨어 엔지니어링 작업 == 개발 + 수정 + 유지보수 

**소프트웨어의 지속 가능성(sustainability)**  
기술, 사업적 이유 등 소프트웨어의 기대 생애 동안 요구되는 모든 가치있는 변경에 대응할 수 있다면 **그 프로젝트는 지속 가능하다** 라고 말할 수 있다.

<br/>

### 1.1 시간과 변경(P. 44~50)
단명하는 코드가 있는가하면, 리눅스 커널, 아파치 HTTP 서버 처럼 반영구적으로 오랜기간 살아남는 프로젝트들이 있다. 이런 프로젝트들의 수명이 언제 다할지 합리적인 방법으로 예측할 수 있을까?

구글에서 진행하는 프로젝트들은 대부분 영원히 생존하리라 가정해야 한다.
다음 그림은 소프트웨어 프로젝트의 기대수명과 업그레이드 중요도의 관계를 보여준다.
![수명과 업그레이드 중요도의 관계](https://github.com/han-chunsik/Algorithm/assets/163226671/6f674a6d-6e4e-43bd-b62c-8c1b81e1371d)

한 번만 실행 될 스크립트를 작성 할때, OS 신버전이 나왔다면 작성을 멈추고 업그레이드를 해야하는가?   
기대 수명 스펙트럼의 최저점과 최고점 사이 어딘가의 전환은 일회성 프로그램과 수십 년을 지속하는 프로젝트 사이에서 발생한다.

**초기부터 업그레이드를 계획하지 않은 프로젝트가 이러한 전환을 고통스러워하는 이유**
* 해당 프로젝트에서 수행해본 적 없는 작업을 진행해야 하므로, 숨어있던 가정들이 수면위로 드러난다.
* 업그레이드 담당이 이런 종류의 작업을 경험해보지 못했다.
* 수 년치 업그레이드를 한 번에 진행해야 하기 때문에 일반 업그레이드보다 작업 규모가 큰 경우가 많다.

이러한 고통을 회피하기보다는 고통을 덜어줄 방법을 찾는 것이 합리적이다. 옳은 선택은 업그레이드 비용, 업그레이드가 가져다줄 이익 프로젝트의 기대수명에 달려있다.

**수명이 길어질수록 '동작한다'와 '유지보수 가능하다'의 차이를 더 분명하게 인지해야 한다.** (~~완벽한 구분은 어렵다. 소프트웨어를 장기간 유지보수 하는 일은 끝나지 않기 떄문...~~)"

<br/>

**1.1.1 하이럼의 법칙(암시적 의존성 법칙 The Law of Implicit Dependencies)**  
다른 엔지니어들이 사용 중인 프로젝트를 유지보수 하고 있다면, '동작한다'와 '유지보수 가능하다'를 구분짓는 가장 중요한 법칙

_"API 사용자가 충분히 많다면 API 명세는 중요하지 않다. 시스템에서 눈에보이는 모든 행위를 누군가는 이용하게 될 것이기 때문"_

API인터페이스를 명확하게 설명해놓아도, 현실에서 사용자는 ~~명세에 없는~~ 기능을 찾아 활용하기도하고, 그 기능이 유용하면 추 후 API를 변경하기 어렵다.  
노출 시간이 길고, 사용자가 많은 프로젝트라면, 가장 무해할것 같은 변경도 일부 사용자의 소프트웨어를 망가뜨릴 수 있다.
변경이 얼마나 유용할지 분석할 때는, 충돌 조사/식별, 해결하는데 따르는 비용도 고려해야 한다.

```
# 모든 변경은 누군가의 워크플로와 충돌한다.

> 관리자: 10.17의 변경사항 - 스페이스바를 누르고 있을 때, CPU가 과열되는 현상 제거
> 오래된 사용자1: 제 워크플로와 충돌하네요. 온도가 급작스럽게 상승하면 스페이스바 대신 다른 키로 인식하도록 한다구요
> 관리자: 그게무슨.....
> 오랜된 사용자2: 전 필요한 기능이에요 옵션 추가해주세요
```

<br/>

**1.1.2 사례: 해시 순서(Hash iteration ordering)**  

```python
# 다음은 해시 기반 집합(set) 원소 다섯개의 출력 순서이다.
>>> for i in {"apple", "banana", "carrot", "durian", "eggplant"}: print(i)
durian
carrot
apple
eggplant
banana
```

이는 '동작한다'와 '옳다'의 차이를 보여주는 예이다.  

대부분의 프로그래머는 해시 테이블의 원소 순서가 나름의 알고리즘에 의해 정해짐을 알고 있다.  
하지만 **그 알고리즘이 언제까지 유지될지 구체적인 정보를 아는 사람은 거의 없다**  

해시 컨테이너의 반복 순서에 의존하더라도 단명할 코드라면 기술적 문제를 겪지 않을테지만, 소프트웨어 엔지니어링 프로젝트에서는 이런 **의존성은 위험 요인**에 해당한다.  

```markdown
<div class="table-wrapper" markdown="block">

|임시방편적인, 기발한 코드|클린, 유지보수 가능한 코드|
|:---:|:---:|
|당장 돌아가야한다"라는 생각으로 작성한 코드|언제까지나 작동해야 한다"라는 생각으로 작성한 코드|
|이용하는 API 명세에 명시되지 않은, 언제든 변할 수 있는 기능을 사용하는 코드|모범사례를 따르고 미래에 대비한 코드|

<div>
```

_"기발한"이 칭찬으로 느껴진다면 프로그래밍, 질책으로 느껴진다면 소프트웨어 엔지니어링"_


<br/>

**1.1.3 '변하지 않기'를 목표로 하지 않는 이유**  
